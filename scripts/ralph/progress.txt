## Codebase Patterns
- Frontend root: `frontend/`, Vite + React + TypeScript project
- Frontend dev: `npm run dev` from `frontend/` directory, port 5173, proxy `/api` -> `http://localhost:8000`
- Frontend types: `frontend/src/types/index.ts` — all TypeScript interfaces matching backend Pydantic models
- Frontend API: `frontend/src/services/api.ts` — axios instance + functions: `loadWorkspace`, `simulate`, `resetWorkspace`, `getHistory`, `getSamples`
- Frontend dependencies: react 19, antd 6, @antv/g6 5.x, axios, @ant-design/icons 6
- Frontend state: `src/hooks/useWorkspace.ts` — WorkspaceContext + useReducer; access via `useWorkspace()` hook; `useSimulation()` wraps simulate API
- Frontend components: `src/components/` — WorkspaceProvider wraps App in `main.tsx`
- Frontend layout: `src/components/Layout/AppLayout.tsx` — three-column layout (280px left Sider + flex Content + 320px right Sider) with Header
- Frontend component structure: ControlPanel (left), GraphCanvas (center), InsightFeed (right), FileUploader (Drawer overlay)
- antd v6 `Sider` does not accept `theme` prop — use className + CSS `background: #fff` instead
- FileUploader uses Drawer (not modal) for upload UI; loads via API then dispatches LOAD_WORKSPACE
- Header pattern: metadata.description as title, action buttons (加载数据 + 重置) on right side
- G6 v5 GraphCanvas: `src/components/GraphCanvas/index.tsx` — creates `Graph` instance on mount, ref-based lifecycle; data reload via `graph.setData()` + `graph.render()`
- G6 v5 node/edge styles: use function callbacks `(datum: NodeData) => style` reading from `ontologyDefRef.current` for zero-hardcoded dynamic styling
- G6 v5 node type mapping: `mapShape()` converts ontology shape strings (circle/diamond/rect) to G6 built-in type names
- G6 v5 events: `NodeEvent.CLICK` handler receives `IElementEvent` (import as type from `@antv/g6`), access node id via `event.target.id`
- G6 v5 selection highlight: `graph.setElementState(stateMap)` with `{nodeId: 'selected' | 'inactive' | []}` pattern; define `node.state.selected` and `node.state.inactive` in Graph options
- G6 v5 auto-resize: `autoResize: true` + `autoFit: 'view'` in Graph constructor; container div must have `width: 100%; height: 100%`
- G6 v5 edge data: edges must have explicit `id` field (generate via `edge-${source}-${target}-${type}-${index}`); `e.source`/`e.target` in EdgeData are strings
- Backend root: `backend/`, FastAPI app at `backend/app/main.py`
- All Pydantic models in `backend/app/models/`, import via `from app.models import ...`
- Run backend commands from `backend/` directory (uvicorn uses `app.main:app`)
- CORS configured for `http://localhost:5173` (Vite dev server)
- Use `pydantic>=2.0` syntax (BaseModel, no `class Config`)
- ActionRegistry in `backend/app/engine/action_registry.py`: use `@register_action` decorator, `ActionContext`/`ActionResult` dataclasses
- OntologyEngine in `backend/app/engine/graph_engine.py`: `load_workspace(schema_dict, action_module)` → builds graph + registers actions; `execute_action(action_id, node_id)` → runs direct effect + ripple rules + pushes to event_queue
- EventQueue in `backend/app/engine/event_queue.py`: `push(action_id, target_node_id, result)` auto-generates ISO timestamp; `get_history()` returns list[dict]; `clear()` empties queue. OntologyEngine holds `self.event_queue`
- DSL parsing: `<-[EDGE_TYPE]- NodeType` = incoming, `-[EDGE_TYPE]-> NodeType` = outgoing; extract edge_type between `[]`, node_type after `]` stripping `->/- ` chars
- `_eval_condition` uses restricted `eval` with `source`/`target` dicts; returns False on any exception
- `_generate_insight` uses `format_map({"source": ..., "target": ...})` to fill insight templates
- `reset()` deep-copies from `initial_snapshot` saved at load time
- Tests go in `backend/tests/`, run with `python -m pytest tests/ -v` from `backend/`
- Action functions in `backend/app/actions/action_functions.py`: all use `(ctx: ActionContext) -> ActionResult` signature, read from `ctx.target_node`/`ctx.params`, return old values in `ActionResult.old_values`
- Use `pytest.approx` for float comparisons in tests
- API routes in `backend/app/api/routes.py`: uses `APIRouter(prefix="/api/v1/workspace")`, registered in `main.py` via `app.include_router()`
- Module-level `engine` singleton in routes.py; tests reset it via `autouse` fixture accessing `from app.api.routes import engine`
- `/load` accepts `UploadFile` via multipart/form-data; validates with `WorkspaceConfig(**data)` before loading
- Use `FastAPI TestClient` (from `fastapi.testclient`) + `io.BytesIO` for file upload tests
- Samples directory: `backend/samples/`, resolved via `pathlib` relative to routes.py (`Path(__file__).resolve().parent.parent.parent / "samples"`)
- `/load` now returns `registered_functions` (list of action names) and `warnings` (list of unregistered function warnings) in response
- `/load` accepts `?sample=name` query param to load built-in samples from `backend/samples/{name}.json`
- `GET /samples` lists available sample JSON files with name + description
- Pydantic validation errors return HTTP 422 with `exc.errors()` detail (list of dicts with `loc`, `msg`, `type`)
- ActionRegistry tracks source labels: `register(name, func, source="builtin")`, `register_from_module(module, source="builtin")`, `list_actions_with_source()` returns `[{name, source}]`
- `load_workspace(schema, action_module, custom_action_module)`: builtin registered first, then custom overrides; same-name custom functions replace builtin
- `/load` accepts optional `action_file` UploadFile for custom Python action files; also auto-loads convention-based `samples/<name>.py` when loading a sample
- `registered_functions` in /load response is now `list[{name: str, source: str}]` (not `list[str]`)
- Dynamic module loading: use `importlib.util.spec_from_file_location` + `module_from_spec` + `exec_module` to load .py files at runtime

# Ralph Progress Log
Started: 2026年 2月11日 星期三 22时17分10秒 CST
---

## 2026-02-11 22:20 - US-BE-001
- What was implemented: Backend project skeleton with FastAPI app and all Pydantic data models
- Files changed:
  - backend/app/main.py (FastAPI app, CORS, health check)
  - backend/app/models/ontology.py (NodeTypeDef, EdgeTypeDef, OntologyDef)
  - backend/app/models/graph.py (GraphNode, GraphEdge, GraphData)
  - backend/app/models/action.py (DirectEffect, EffectOnTarget, RippleRule, Action, ActionEngine)
  - backend/app/models/workspace.py (Metadata, WorkspaceConfig)
  - backend/app/models/api.py (SimulateRequest, InsightItem, DeltaGraph, SimulateResponse)
  - backend/requirements.txt
  - .gitignore
- **Learnings for future iterations:**
  - All dependencies already installed in conda env, no virtualenv needed
  - RippleRule has `insight_type` and `insight_severity` as direct fields (not nested)
  - Models __init__.py re-exports all models for convenient import
---

## 2026-02-11 - US-BE-002
- What was implemented: ActionRegistry function registry with @register_action decorator, ActionContext/ActionResult dataclasses
- Files changed:
  - backend/app/engine/action_registry.py (ActionContext, ActionResult, @register_action, ActionRegistry class)
  - backend/tests/test_action_registry.py (12 tests covering all acceptance criteria)
- **Learnings for future iterations:**
  - ActionContext and ActionResult are plain dataclasses (not Pydantic), keeping engine layer lightweight
  - `register_from_module` uses `inspect.getmembers(module, callable)` to scan for decorated functions
  - `@register_action` sets `_is_action = True` and `_action_name = func.__name__` on the function object
  - `list_actions()` returns sorted names for deterministic ordering
  - Sandbox mode blocks heredoc-style git commits; use inline `-m` flag instead
---

## 2026-02-11 - US-BE-003
- What was implemented: L1/L2/L3 action functions in actions/action_functions.py
  - L1 Data: `set_property`, `adjust_numeric`, `update_risk_status`
  - L2 Information: `recalculate_valuation`, `compute_margin_gap`
  - L3 Intelligence: `graph_weighted_exposure` (sum/max/count aggregation, direction/edge_type filtering)
- Files changed:
  - backend/app/actions/action_functions.py (6 action functions, all @register_action decorated)
  - backend/tests/test_action_functions.py (20 tests covering all functions + registration)
- **Learnings for future iterations:**
  - All action functions follow uniform `(ctx: ActionContext) -> ActionResult` signature
  - `graph_weighted_exposure` uses `graph.in_edges`/`out_edges` with `data=True` to get edge attributes
  - Floating point precision: use `pytest.approx` for float comparisons in tests
  - Functions read from `ctx.target_node` (dict of node properties) and `ctx.params` (action parameters)
  - Functions return old values in `ActionResult.old_values` for undo/reset capability
---

## 2026-02-11 - US-BE-004
- What was implemented: OntologyEngine core engine in engine/graph_engine.py
  - `load_workspace(schema, action_module)`: parses graph_data → NetworkX DiGraph, saves initial_snapshot, registers action functions
  - `execute_action(action_id, target_node_id)`: applies direct_effect, processes ripple_rules, returns structured results
  - `_process_ripple_rule`: parses Cypher-style DSL paths, filters by edge_type/node_type, evaluates conditions, applies secondary effects
  - `_parse_propagation_path`: handles both `<-[TYPE]- Node` (incoming) and `-[TYPE]-> Node` (outgoing) DSL formats
  - `_apply_secondary_effect`: looks up registered function, builds ActionContext, executes, writes results back to graph
  - `_generate_insight`: fills insight templates with source/target node attributes via format_map
  - `get_graph_for_render()`: exports graph in frontend-friendly format
  - `get_available_actions(node_id)`: filters actions by node type
  - `reset()`: deep-copies initial_snapshot back to all nodes
- Files changed:
  - backend/app/engine/graph_engine.py (OntologyEngine class, ~280 lines)
  - backend/tests/test_graph_engine.py (39 tests covering load, DSL, execute, reset, render, actions, conditions)
- **Learnings for future iterations:**
  - DSL parser: outgoing path `-> ` uses different separator than incoming `- `; parse by stripping chars after `]` instead of splitting on a fixed separator
  - `_find_action` handles both dict and Pydantic model forms (schema may come from JSON dict or Pydantic)
  - `get_available_actions` also needs to handle both dict and Pydantic model forms for action objects
  - `format_map` with `{"source": dict, "target": dict}` allows templates like `{target[name]}` to reference nested properties
  - `eval` for conditions uses `{"__builtins__": {}}` for minimal safety; conditions reference `source`/`target` dicts
  - Full test suite: 71 tests (32 previous + 39 new), all passing
---

## 2026-02-11 - US-BE-005
- What was implemented: EventQueue event recording system
  - `SimulationEvent` dataclass: timestamp, action_id, target_node_id, ripple_path, insights, delta_graph
  - `EventQueue` class: push (auto ISO timestamp), get_history (chronological dict list), clear
  - Integrated into `OntologyEngine.execute_action`: pushes event after successful execution (not on error)
- Files changed:
  - backend/app/engine/event_queue.py (SimulationEvent dataclass + EventQueue class)
  - backend/app/engine/graph_engine.py (added event_queue import, attribute, and push call)
  - backend/tests/test_event_queue.py (12 tests: unit + engine integration)
- **Learnings for future iterations:**
  - EventQueue only records successful actions (error results skip push)
  - `execute_action` stores result in local var before returning, to pass to event_queue.push
  - Sandbox blocks heredoc-style git commits (`$(cat <<'EOF'...)`); use inline `-m` with `dangerouslyDisableSandbox`
  - Full test suite: 83 tests (71 previous + 12 new), all passing
---

## 2026-02-11 - US-BE-006
- What was implemented: FastAPI route layer with 4 REST API endpoints
  - `POST /api/v1/workspace/load`: accepts multipart/form-data file upload, validates JSON → Pydantic → engine.load_workspace
  - `POST /api/v1/workspace/simulate`: accepts SimulateRequest JSON body, calls engine.execute_action, returns SimulateResponse
  - `POST /api/v1/workspace/reset`: resets engine state + clears event history, returns reset graph data
  - `GET /api/v1/workspace/history`: returns event_queue.get_history()
  - All endpoints include 400 error handling for invalid input / missing workspace
  - Routes registered in main.py via `app.include_router(workspace_router)`
- Files changed:
  - backend/app/api/routes.py (4 endpoints, module-level engine singleton)
  - backend/app/main.py (added router import and include_router)
  - backend/tests/test_routes.py (17 tests: load/simulate/reset/history/health)
- **Learnings for future iterations:**
  - Use `fastapi.testclient.TestClient` with `io.BytesIO` for file upload tests
  - Module-level `engine = OntologyEngine()` in routes.py is the shared singleton; tests import and reset it directly
  - `UploadFile | None = File(None)` allows optional file upload alongside query params
  - `response_model=SimulateResponse` on the simulate endpoint enforces output schema
  - autouse fixture resets engine state before each test to avoid cross-test pollution
  - Full test suite: 100 tests (83 previous + 17 new), all passing
---

## 2026-02-11 - US-CORE-001
- What was implemented: Complete knowledge graph loading pipeline (JSON parse → Pydantic validation → graph build → function injection)
  - `GET /api/v1/workspace/samples`: returns list of available sample JSON files with name + description
  - `POST /load` enhanced to support `?sample=corporate_acquisition` query param for built-in sample loading
  - Pydantic validation errors now return HTTP 422 with field-level error details (not 400)
  - Function name validation: after loading, checks all `action_to_trigger` references against ActionRegistry; returns warnings for unregistered functions
  - Response now includes `registered_functions` (sorted list of action names) and `warnings` (list of unregistered function warnings)
  - Idempotent: `load_workspace` clears graph + rebuilds action_registry each time
  - `backend/samples/corporate_acquisition.json`: built-in sample data file
- Files changed:
  - backend/app/api/routes.py (added GET /samples, enhanced POST /load with sample loading, 422 validation, function warnings, registered_functions)
  - backend/tests/test_routes.py (added 10 new tests: samples list, sample loading, 422 validation, function warnings, registered_functions, idempotency)
  - backend/samples/corporate_acquisition.json (new: built-in sample data)
- **Learnings for future iterations:**
  - `SAMPLES_DIR` resolved via `Path(__file__).resolve().parent.parent.parent / "samples"` — 3 levels up from routes.py to backend/
  - Use `pydantic.ValidationError` (not generic Exception) to catch Pydantic errors and get `.errors()` list
  - `_check_unregistered_functions` runs AFTER `load_workspace` so the registry is populated before checking
  - Sample loading uses query params (`?sample=name`), not JSON body, to avoid conflict with multipart/form-data file upload
  - Full test suite: 110 tests (100 previous + 10 new), all passing
---

## 2026-02-11 - US-CORE-002
- What was implemented: Custom Action function extension mechanism (user-injectable business functions)
  - ActionRegistry now tracks source labels (`builtin` / `custom`) for each registered function
  - `list_actions_with_source()` returns `[{name, source}]` for the /load response
  - `OntologyEngine.load_workspace` accepts optional `custom_action_module` parameter; builtin registered first, custom overrides same-name functions
  - `/load` endpoint accepts optional `action_file` UploadFile for custom Python action files
  - Convention-based loading: when loading a sample (e.g. `corporate_acquisition`), auto-checks for `samples/corporate_acquisition.py` and loads it
  - Dynamic module loading via `importlib.util.spec_from_file_location` + temp file for uploaded .py content
  - `registered_functions` in /load response changed from `list[str]` to `list[{name: str, source: str}]`
  - Security note: only scans `@register_action` decorated functions (POC stage)
- Files changed:
  - backend/app/engine/action_registry.py (added `_sources` dict, `source` param to register/register_from_module, `list_actions_with_source()`)
  - backend/app/engine/graph_engine.py (added `custom_action_module` param to `load_workspace`)
  - backend/app/api/routes.py (added `_load_module_from_path`, `_find_convention_action_file`, `action_file` param, convention-based loading, source-tracked response)
  - backend/tests/test_action_registry.py (added 5 tests: source tracking, override, sorted, default)
  - backend/tests/test_routes.py (updated existing test for new format, added 8 tests: custom upload, override, convention, signature, source format)
- **Learnings for future iterations:**
  - `importlib.util.spec_from_file_location` requires a real file path, so uploaded .py bytes must be written to a temp file first
  - Convention-based .py files live alongside JSON in `samples/` directory with the same stem name
  - Custom module is registered AFTER builtin module, so same-name functions get overridden (last-write-wins in dict)
  - Tests that create convention files in `samples/` must clean up in a `finally` block to avoid polluting other tests
  - Full test suite: 123 tests (110 previous + 13 new), all passing
---

## 2026-02-11 - US-DATA-001
- What was implemented: Enhanced corporate_acquisition.json sample data with full risk propagation scenario
  - Expanded from 4 to 8 nodes: 4 Companies (Alpha, Beta, Gamma, Delta) + 2 Event_Acquisition + 2 Person (陈明远, 李志华)
  - Expanded from 4 to 10 edges: ACQUIRES, TARGET_OF, SUPPLIES_TO (with dependency_weight), BOARD_MEMBER_OF
  - Added Person node type (green circle) and BOARD_MEMBER_OF edge type to ontology_def
  - trigger_acquisition_failure now has 5 ripple rules covering L1/L2/L3:
    - R001: recalculate_valuation (L2, critical, quantitative_impact)
    - R002: update_risk_status (L1, warning, risk_propagation)
    - R003: adjust_numeric (L1, warning, quantitative_impact)
    - R004: graph_weighted_exposure (L3, critical, network_analysis)
    - R005: set_property (L1, info, recommendation)
  - trigger_acquisition_success now has 2 ripple rules with event_trigger and quantitative_impact insights
  - Insight types covered: quantitative_impact, risk_propagation, network_analysis, recommendation, event_trigger
  - Insight severities covered: critical, warning, info
  - Created comprehensive test_sample_data.py (26 tests) validating all acceptance criteria
- Files changed:
  - backend/samples/corporate_acquisition.json (enhanced from 4→8 nodes, 4→10 edges, 2→5 ripple rules)
  - backend/tests/test_sample_data.py (new: 26 tests covering structure, engine loading, execution, and reset)
- **Learnings for future iterations:**
  - Tests in test_graph_engine.py and test_routes.py use their own inline `_build_sample_schema()` — modifying the sample JSON file does NOT break those tests
  - The sample JSON tests (test_sample_data.py) load the actual file via `Path(__file__).resolve().parent.parent / "samples"` — same pattern as routes.py
  - `graph_weighted_exposure` with `direction=in` and `edge_type=SUPPLIES_TO` correctly traverses incoming supply chain edges on C_ALPHA
  - Ripple rules for E_ACQ_101 fire on both `<-[ACQUIRES]- Company` (→ C_ALPHA) and `<-[TARGET_OF]- Company` (→ C_BETA), giving ripple_path ≥ 3
  - Full test suite: 149 tests (123 previous + 26 new), all passing
---

## 2026-02-11 - US-BE-007
- What was implemented: Backend engine end-to-end integration verification test suite
  - `TestEngineFullPipeline` (16 tests): validates the complete engine-level pipeline — load → execute → check results → reset → re-execute
    - Node/edge counts match JSON, execute returns success, updated_nodes include direct + ripple targets
    - highlight_edges on propagation path, 3+ insight types, critical severity present
    - Insight text has no unfilled placeholders, all insights are structured objects
    - Reset restores initial state, re-execute after reset gives consistent results
    - action_registry.list_actions() contains all 6 registered function names
    - Event queue records executions correctly (1 and 2 events after 1 and 2 simulations)
  - `TestAPIEndToEnd` (9 tests): validates all 4 API endpoints via FastAPI TestClient
    - /health, /load (sample + file upload), /simulate, /reset, /history, /samples
    - Full round-trip test: load → simulate → verify → reset → simulate again → verify consistency
- Files changed:
  - backend/tests/test_e2e_integration.py (new: 25 tests in 2 test classes)
- **Learnings for future iterations:**
  - TestClient (from fastapi.testclient) is synchronous despite async endpoints — no need for httpx.AsyncClient in tests
  - Engine-level tests use standalone OntologyEngine instances; API-level tests use the module-level singleton from routes.py
  - Consistency check (same results after reset) compares sorted insight types + sorted ripple paths, not raw lists (order may vary between insight items)
  - Full test suite: 174 tests (149 previous + 25 new), all passing
---

## 2026-02-11 - US-FE-001
- What was implemented: Frontend project initialization with Vite + React + TypeScript + Ant Design + G6
  - Created `frontend/` directory via `npm create vite@latest` with react-ts template
  - Installed all required dependencies: react 19, antd 6, @antv/g6 5.x, axios, @ant-design/icons 6
  - Configured `vite.config.ts`: port 5173, proxy `/api` -> `http://localhost:8000`
  - Created `src/types/index.ts`: all TypeScript interfaces matching backend Pydantic models (NodeTypeDef, EdgeTypeDef, OntologyDef, GraphNode, GraphEdge, GraphData, Action, InsightItem, SimulateResponse, LoadResponse, etc.)
  - Created `src/services/api.ts`: axios instance + 5 API functions (loadWorkspace, simulate, resetWorkspace, getHistory, getSamples)
- Files changed:
  - frontend/ (entire new directory: 18 files)
  - Key files: vite.config.ts, src/types/index.ts, src/services/api.ts, package.json
- **Learnings for future iterations:**
  - Vite creates the project with React 19 (latest), not 18 — should be fine for this POC
  - antd installed as v6 (latest), not v5 — API is similar but check for breaking changes if needed
  - `npm run build` runs `tsc -b && vite build` (TypeScript check before Vite build)
  - Proxy config in vite.config.ts handles `/api` prefix forwarding to backend
  - `loadWorkspace` accepts either `File` (for uploads) or `string` (for sample name), uses different API call paths
---

## 2026-02-11 - US-FE-002
- What was implemented: React Context global state management with useReducer
  - `src/hooks/useWorkspace.ts`: WorkspaceState interface, WorkspaceAction union type, workspaceReducer pure function, WorkspaceContext, useWorkspace() hook, useWorkspaceReducer() helper
  - `src/hooks/useSimulation.ts`: useSimulation() hook wrapping simulate API with SIMULATE_START/DONE dispatch
  - `src/components/WorkspaceProvider.tsx`: Context provider component using useWorkspaceReducer
  - `main.tsx`: App wrapped with WorkspaceProvider
  - `App.tsx`: Updated to use useWorkspace() as smoke test
- Files changed:
  - frontend/src/hooks/useWorkspace.ts (new: ~140 lines — state, actions, reducer, context, hook)
  - frontend/src/hooks/useSimulation.ts (new: ~45 lines — simulation wrapper)
  - frontend/src/components/WorkspaceProvider.tsx (new: ~15 lines — provider component)
  - frontend/src/main.tsx (added WorkspaceProvider wrapping)
  - frontend/src/App.tsx (replaced boilerplate with useWorkspace smoke test)
- **Learnings for future iterations:**
  - React 19 uses `<Context value={...}>` instead of `<Context.Provider value={...}>` (no `.Provider` needed)
  - WorkspaceState includes `simulationHistory: SimulationHistoryEntry[]` for tracking all simulation runs (each with insights, ripplePath, timestamp)
  - `insights` in state is a flat array of ALL insights from all simulations; `simulationHistory` groups them by simulation run
  - `LOAD_WORKSPACE` resets entire state to initial (clears selections, insights, history) — idempotent
  - `RESET` only clears selections/insights/history but keeps metadata/ontologyDef/graphData/actions (mirrors backend /reset behavior)
  - `useSimulation` depends on `state.selectedNodeId` — returns early if no node selected
  - Frontend hooks in `src/hooks/`, components in `src/components/`
---

## 2026-02-11 - US-FE-003
- What was implemented: Three-column layout shell with Header, FileUploader, and placeholder panels
  - `AppLayout.tsx`: Ant Design Layout with Header (metadata title + action buttons) + 3-column body (280px left Sider + flex Content + 320px right Sider)
  - `FileUploader/index.tsx`: Upload.Dragger for JSON file drag-and-drop + Select dropdown for built-in samples (fetched from GET /samples)
  - `ControlPanel/index.tsx`: Placeholder component for left panel (will be implemented in US-FE-005)
  - `GraphCanvas/index.tsx`: Placeholder component for center canvas (will be implemented in US-FE-004)
  - `InsightFeed/index.tsx`: Placeholder component for right panel (will be implemented in US-FE-006)
  - Header shows metadata.description when workspace loaded, "加载数据" button opens Drawer with FileUploader, "重置" button calls resetWorkspace API + dispatches RESET
  - Updated index.css for full-viewport layout, App.css for layout-specific styles
- Files changed:
  - frontend/src/components/Layout/AppLayout.tsx (new)
  - frontend/src/components/FileUploader/index.tsx (new)
  - frontend/src/components/ControlPanel/index.tsx (new)
  - frontend/src/components/GraphCanvas/index.tsx (new)
  - frontend/src/components/InsightFeed/index.tsx (new)
  - frontend/src/App.tsx (replaced with AppLayout render)
  - frontend/src/App.css (layout styles)
  - frontend/src/index.css (full-viewport reset)
- **Learnings for future iterations:**
  - antd v6 Layout.Sider does not have a `theme` prop — use className + CSS for background color
  - Use Drawer (not Modal) for file upload overlay — feels more natural for a side panel action
  - FileUploader fetches samples on mount via useEffect; failure is silently caught (backend may not be running)
  - Upload.Dragger with `beforeUpload={() => false}` prevents auto-upload; use `onChange` to get the file
  - Full build (tsc -b + vite build) passes; chunk size warning for antd+G6 is expected
---

## 2026-02-12 - US-FE-004
- What was implemented: GraphCanvas component with AntV G6 5.x for knowledge graph rendering
  - Dynamic node type/shape from ontologyDef (circle for Company/Person, diamond for Event_Acquisition)
  - Dynamic node fill color from ontologyDef (blue for Company, orange for Event, green for Person)
  - Dynamic edge styles from ontologyDef (solid/dashed, colored, with direction arrows)
  - Node labels from properties.name (fallback to id), edge labels from ontologyDef.edge_types.label
  - d3-force layout with preventOverlap, collision, and repulsive force tuning
  - Node click dispatches SELECT_NODE (with nodeId + nodeType), canvas click dispatches DESELECT_NODE
  - Selected node highlight (red stroke + halo), inactive nodes dimmed (opacity 0.35), related edges kept visible
  - Auto-resize via `autoResize: true` + `autoFit: 'view'`
  - Drag-canvas, zoom-canvas, drag-element behaviors
  - Placeholder shown when no graphData loaded
- Files changed:
  - frontend/src/components/GraphCanvas/index.tsx (replaced placeholder with full G6 implementation, ~268 lines)
- **Learnings for future iterations:**
  - G6 v5 event handlers: `graph.on(NodeEvent.CLICK, ...)` receives `IEvent` union type; use `IElementEvent` type annotation (exported from `@antv/g6`) to get `event.target.id`
  - G6 v5 node/edge style callbacks: read ontologyDef from a ref (`ontologyDefRef.current`) inside callbacks — the Graph is created once on mount but needs latest ontologyDef on each render
  - G6 v5 requires explicit edge IDs (unlike v4 auto-generated) — generate via `edge-${source}-${target}-${type}-${index}`
  - G6 v5 `setElementState` accepts a map of `{elementId: state | state[]}` for batch updates — more efficient than per-element calls
  - `mapShape()` normalizes ontology shape names to G6 built-in types; `diamond` maps directly, `circle` is default
  - Use `useRef` pattern for dispatch/state to avoid re-creating Graph instance on every state change
  - Backend tests (174) still passing — no backend changes in this story
---

## 2026-02-12 - US-FE-005
- What was implemented: ControlPanel dynamic control panel with three sections
  - Node Properties Card: displays selected node's type tag, id tag, and all properties via Ant Design Descriptions (bordered, single-column); shows Empty placeholder when no node selected
  - Action Buttons: filters actions by `target_node_type === selectedNodeType`; renders `display_name` as primary block Button; wired to `useSimulation().onSimulate(action_id)`; disabled + loading during simulation
  - Legend: iterates `ontologyDef.node_types` to render color dots + Chinese labels
  - Sections separated by Divider; actions/legend sections only render when data is available
- Files changed:
  - frontend/src/components/ControlPanel/index.tsx (replaced placeholder with full implementation, ~160 lines)
- **Learnings for future iterations:**
  - `useSimulation()` hook returns `{ onSimulate, isSimulating }` — call `onSimulate(actionId)` directly, it reads `selectedNodeId` from state internally
  - Actions are filtered by `target_node_type` matching `selectedNodeType` from workspace state — no additional API call needed
  - `graphData.nodes` contains all node data with properties — find selected node via `nodes.find(n => n.id === selectedNodeId)`
  - Ant Design `Descriptions` with `column={1} size="small" bordered` works well for key-value property display in a narrow panel
  - Frontend build passes; chunk size warning for antd+G6 is expected and harmless
  - Backend tests (174) still passing — no backend changes in this story
---
